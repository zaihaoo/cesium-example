/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.114
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as Gt,b as Xt}from"./chunk-7YZBR6L3.js";import{a as kt}from"./chunk-ON3Y6OZW.js";import{a as lt}from"./chunk-K7DZ26MZ.js";import{a as Dt}from"./chunk-AM36JLPO.js";import"./chunk-NQBIZOW4.js";import"./chunk-RNO4G5Q4.js";import{a as qt}from"./chunk-OFYQOYUL.js";import"./chunk-5W56CV6U.js";import"./chunk-FW5QB3YT.js";import{d as Ot,i as zt}from"./chunk-VUQ65SO2.js";import"./chunk-XHQXTKN5.js";import{b as $,c as Lt}from"./chunk-CAREXCTE.js";import"./chunk-PF7ABWYW.js";import{a as P,b as T,c as wt,d as Ht}from"./chunk-6A72MMRO.js";import{a as r}from"./chunk-4BEFMW7D.js";import"./chunk-UMJEX7YU.js";import{a as Vt}from"./chunk-72JWF3LF.js";import{a as Ut}from"./chunk-2F4MHS2T.js";import"./chunk-3Z2AZRQC.js";import{e as ht}from"./chunk-A5XXOFX2.js";var te=Uint16Array.BYTES_PER_ELEMENT,mt=Int32Array.BYTES_PER_ELEMENT,Pt=Uint32Array.BYTES_PER_ELEMENT,ee=Float32Array.BYTES_PER_ELEMENT,H=Float64Array.BYTES_PER_ELEMENT;function tt(n,l,e){e=Ut(e,r);let i=n.length;for(let c=0;c<i;++c)if(e.equalsEpsilon(n[c],l,r.EPSILON12))return c;return-1}function oe(n,l){n.ellipsoid=Ht.clone(n.ellipsoid),n.rectangle=Lt.clone(n.rectangle);let e=se(n.buffer,n.relativeToCenter,n.ellipsoid,n.rectangle,n.nativeRectangle,n.exaggeration,n.exaggerationRelativeHeight,n.skirtHeight,n.includeWebMercatorT,n.negativeAltitudeExponentBias,n.negativeElevationThreshold),i=e.vertices;l.push(i.buffer);let c=e.indices;return l.push(c.buffer),{vertices:i.buffer,indices:c.buffer,numberOfAttributes:e.encoding.stride,minimumHeight:e.minimumHeight,maximumHeight:e.maximumHeight,boundingSphere3D:e.boundingSphere3D,orientedBoundingBox:e.orientedBoundingBox,occludeePointInScaledSpace:e.occludeePointInScaledSpace,encoding:e.encoding,vertexCountWithoutSkirts:e.vertexCountWithoutSkirts,indexCountWithoutSkirts:e.indexCountWithoutSkirts,westIndicesSouthToNorth:e.westIndicesSouthToNorth,southIndicesEastToWest:e.southIndicesEastToWest,eastIndicesNorthToSouth:e.eastIndicesNorthToSouth,northIndicesWestToEast:e.northIndicesWestToEast}}var u=new T,G=new P,ne=new P,ie=new P,re=new $;function se(n,l,e,i,c,et,m,ot,B,nt,it){let E,h,x,f,S,p;ht(i)?(E=i.west,h=i.south,x=i.east,f=i.north,S=i.width,p=i.height):(E=r.toRadians(c.west),h=r.toRadians(c.south),x=r.toRadians(c.east),f=r.toRadians(c.north),S=r.toRadians(i.width),p=r.toRadians(i.height));let X=[h,f],A=[E,x],V=zt.eastNorthUpToFixedFrame(l,e),j=$.inverseTransformation(V,re),L,Q;B&&(L=lt.geodeticLatitudeToMercatorAngle(h),Q=1/(lt.geodeticLatitudeToMercatorAngle(f)-L));let b=et!==1,a=new DataView(n),O=Number.POSITIVE_INFINITY,J=Number.NEGATIVE_INFINITY,y=ne;y.x=Number.POSITIVE_INFINITY,y.y=Number.POSITIVE_INFINITY,y.z=Number.POSITIVE_INFINITY;let F=ie;F.x=Number.NEGATIVE_INFINITY,F.y=Number.NEGATIVE_INFINITY,F.z=Number.NEGATIVE_INFINITY;let o=0,N=0,At=0,rt,z;for(z=0;z<4;++z){let t=o;rt=a.getUint32(t,!0),t+=Pt;let d=r.toRadians(a.getFloat64(t,!0)*180);t+=H,tt(A,d)===-1&&A.push(d);let Y=r.toRadians(a.getFloat64(t,!0)*180);t+=H,tt(X,Y)===-1&&X.push(Y),t+=2*H;let w=a.getInt32(t,!0);t+=mt,N+=w,w=a.getInt32(t,!0),At+=w*3,o+=rt+Pt}let bt=[],yt=[],g=new Array(N),M=new Array(N),R=new Array(N),_=B?new Array(N):[],C=b?new Array(N):[],v=new Array(At),k=[],st=[],ct=[],W=[],s=0,pt=0;for(o=0,z=0;z<4;++z){rt=a.getUint32(o,!0),o+=Pt;let t=o,d=r.toRadians(a.getFloat64(o,!0)*180);o+=H;let Y=r.toRadians(a.getFloat64(o,!0)*180);o+=H;let w=r.toRadians(a.getFloat64(o,!0)*180),Ct=w*.5;o+=H;let vt=r.toRadians(a.getFloat64(o,!0)*180),Wt=vt*.5;o+=H;let Yt=a.getInt32(o,!0);o+=mt;let Zt=a.getInt32(o,!0);o+=mt,o+=mt;let St=new Array(Yt);for(let U=0;U<Yt;++U){let Z=d+a.getUint8(o++)*w;u.longitude=Z;let D=Y+a.getUint8(o++)*vt;u.latitude=D;let I=a.getFloat32(o,!0);if(o+=ee,Number.isFinite(I)||(I=0),I!==0&&I<it&&(I*=-Math.pow(2,nt)),I*=6371010,u.height=I,tt(A,Z)!==-1||tt(X,D)!==-1){let dt=tt(bt,u,T);if(dt===-1)bt.push(T.clone(u)),yt.push(s);else{St[U]=yt[dt];continue}}St[U]=s,Math.abs(Z-E)<Ct?k.push({index:s,cartographic:T.clone(u)}):Math.abs(Z-x)<Ct?ct.push({index:s,cartographic:T.clone(u)}):Math.abs(D-h)<Wt?st.push({index:s,cartographic:T.clone(u)}):Math.abs(D-f)<Wt&&W.push({index:s,cartographic:T.clone(u)}),O=Math.min(I,O),J=Math.max(I,J),R[s]=I;let Nt=e.cartographicToCartesian(u);if(g[s]=Nt,B&&(_[s]=(lt.geodeticLatitudeToMercatorAngle(D)-L)*Q),b){let dt=e.geodeticSurfaceNormal(Nt);C[s]=dt}$.multiplyByPoint(j,Nt,G),P.minimumByComponent(G,y,y),P.maximumByComponent(G,F,F);let Tt=(Z-E)/(x-E);Tt=r.clamp(Tt,0,1);let Bt=(D-h)/(f-h);Bt=r.clamp(Bt,0,1),M[s]=new wt(Tt,Bt),++s}let $t=Zt*3;for(let U=0;U<$t;++U,++pt)v[pt]=St[a.getUint16(o,!0)],o+=te;if(rt!==o-t)throw new Vt("Invalid terrain tile.")}g.length=s,M.length=s,R.length=s,B&&(_.length=s),b&&(C.length=s);let Ft=s,jt=pt,K={hMin:O,lastBorderPoint:void 0,skirtHeight:ot,toENU:j,ellipsoid:e,minimum:y,maximum:F};k.sort(function(t,d){return d.cartographic.latitude-t.cartographic.latitude}),st.sort(function(t,d){return t.cartographic.longitude-d.cartographic.longitude}),ct.sort(function(t,d){return t.cartographic.latitude-d.cartographic.latitude}),W.sort(function(t,d){return d.cartographic.longitude-t.cartographic.longitude});let q=1e-5;if(gt(g,R,M,_,C,v,K,k,-q*S,!0,-q*p),gt(g,R,M,_,C,v,K,st,-q*p,!1),gt(g,R,M,_,C,v,K,ct,q*S,!0,q*p),gt(g,R,M,_,C,v,K,W,q*p,!1),k.length>0&&W.length>0){let t=k[0].index,d=Ft,Y=W[W.length-1].index,w=g.length-1;v.push(Y,w,d,d,t,Y)}N=g.length;let Qt=Ot.fromPoints(g),Mt;ht(i)&&(Mt=Dt.fromRectangle(i,O,J,e));let Jt=new Gt(e).computeHorizonCullingPointPossiblyUnderEllipsoid(l,g,O),Kt=new qt(y,F,l),It=new Xt(l,Kt,K.hMin,J,V,!1,B,b,et,m),Rt=new Float32Array(N*It.stride),_t=0;for(let t=0;t<N;++t)_t=It.encode(Rt,_t,g[t],M[t],R[t],void 0,_[t],C[t]);let at=k.map(function(t){return t.index}).reverse(),Et=st.map(function(t){return t.index}).reverse(),ut=ct.map(function(t){return t.index}).reverse(),xt=W.map(function(t){return t.index}).reverse();return Et.unshift(ut[ut.length-1]),Et.push(at[0]),xt.unshift(at[at.length-1]),xt.push(ut[0]),{vertices:Rt,indices:new Uint16Array(v),maximumHeight:J,minimumHeight:O,encoding:It,boundingSphere3D:Qt,orientedBoundingBox:Mt,occludeePointInScaledSpace:Jt,vertexCountWithoutSkirts:Ft,indexCountWithoutSkirts:jt,westIndicesSouthToNorth:at,southIndicesEastToWest:Et,eastIndicesNorthToSouth:ut,northIndicesWestToEast:xt}}function gt(n,l,e,i,c,et,m,ot,B,nt,it){let E=ot.length;for(let h=0;h<E;++h){let x=ot[h],f=x.cartographic,S=x.index,p=n.length,X=f.longitude,A=f.latitude;A=r.clamp(A,-r.PI_OVER_TWO,r.PI_OVER_TWO);let V=f.height-m.skirtHeight;m.hMin=Math.min(m.hMin,V),T.fromRadians(X,A,V,u),nt&&(u.longitude+=B),nt?h===E-1?u.latitude+=it:h===0&&(u.latitude-=it):u.latitude+=B;let j=m.ellipsoid.cartographicToCartesian(u);n.push(j),l.push(V),e.push(wt.clone(e[S])),i.length>0&&i.push(i[S]),c.length>0&&c.push(c[S]),$.multiplyByPoint(m.toENU,j,G);let L=m.minimum,Q=m.maximum;P.minimumByComponent(G,L,L),P.maximumByComponent(G,Q,Q);let ft=m.lastBorderPoint;if(ht(ft)){let b=ft.index;et.push(b,p-1,p,p,S,b)}m.lastBorderPoint=x}}var Ae=kt(oe);export{Ae as default};
