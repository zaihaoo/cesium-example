/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.114
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as dt}from"./chunk-UFTYIC6P.js";import{a as L}from"./chunk-6RLGDJNX.js";import{a as at}from"./chunk-KGSL5AZH.js";import{a as st}from"./chunk-LAFYIXBI.js";import{a as bt}from"./chunk-I6PJ2W53.js";import"./chunk-NQBIZOW4.js";import"./chunk-G3ANYX6B.js";import{a as ht}from"./chunk-H3IXAINZ.js";import{a as K}from"./chunk-SCJI2CER.js";import{a as X}from"./chunk-RNO4G5Q4.js";import"./chunk-OFYQOYUL.js";import{a as gt,b as nt}from"./chunk-OW2TE3OQ.js";import"./chunk-GLM7D42Y.js";import"./chunk-7UQWW73Z.js";import{a as wt,b as yt}from"./chunk-5W56CV6U.js";import"./chunk-FW5QB3YT.js";import{a as lt}from"./chunk-Y3QWB4WF.js";import"./chunk-KJJSAVM5.js";import{c as mt,d as Z}from"./chunk-RL3FEXRM.js";import{d as Tt,f as ct}from"./chunk-VUQ65SO2.js";import"./chunk-XHQXTKN5.js";import{c as _t}from"./chunk-CAREXCTE.js";import{a as Q}from"./chunk-PF7ABWYW.js";import{a,b as ot,c as E,d as V,e as W}from"./chunk-6A72MMRO.js";import{a as l}from"./chunk-4BEFMW7D.js";import"./chunk-UMJEX7YU.js";import"./chunk-72JWF3LF.js";import{a as v}from"./chunk-2F4MHS2T.js";import{a as ut,b as q}from"./chunk-3Z2AZRQC.js";import{e as P}from"./chunk-A5XXOFX2.js";function b(t,e){this.position=t,P(this.position)||(this.position=new E),this.tangentPlane=e,P(this.tangentPlane)||(this.tangentPlane=b.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(b.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=E.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(l.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=l.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=l.TWO_PI),t}}});var it=new ot,Rt=new a;b.prototype.getLatitude=function(t){P(t)||(t=V.WGS84),it.latitude=this.conformalLatitude,it.longitude=this.longitude,it.height=0;let e=this.ellipsoid.cartographicToCartesian(it,Rt);return t.cartesianToCartographic(e,it),it.latitude};var It=new wt,vt=new a,Lt=new a;b.fromCartesian=function(t,e){q.defined("cartesian",t);let o=l.signNotZero(t.z),n=b.NORTH_POLE_TANGENT_PLANE,s=b.SOUTH_POLE;o<0&&(n=b.SOUTH_POLE_TANGENT_PLANE,s=b.NORTH_POLE);let i=It;i.origin=n.ellipsoid.scaleToGeocentricSurface(t,i.origin),i.direction=a.subtract(i.origin,s,vt),a.normalize(i.direction,i.direction);let r=yt.rayPlane(i,n.plane,Lt),h=a.subtract(r,s,r),d=a.dot(n.xAxis,h),u=o*a.dot(n.yAxis,h);return P(e)?(e.position=new E(d,u),e.tangentPlane=n,e):new b(new E(d,u),n)};b.fromCartesianArray=function(t,e){q.defined("cartesians",t);let o=t.length;P(e)?e.length=o:e=new Array(o);for(let n=0;n<o;n++)e[n]=b.fromCartesian(t[n],e[n]);return e};b.clone=function(t,e){if(P(t))return P(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new b(t.position,t.tangentPlane)};b.HALF_UNIT_SPHERE=Object.freeze(new V(.5,.5,.5));b.NORTH_POLE=Object.freeze(new a(0,0,.5));b.SOUTH_POLE=Object.freeze(new a(0,0,-.5));b.NORTH_POLE_TANGENT_PLANE=Object.freeze(new X(b.NORTH_POLE,b.HALF_UNIT_SPHERE));b.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new X(b.SOUTH_POLE,b.HALF_UNIT_SPHERE));var z=b;var Ft=new ot,Ot=new ot;function St(t,e,o,n){let i=n.cartesianToCartographic(t,Ft).height,r=n.cartesianToCartographic(e,Ot);r.height=i,n.cartographicToCartesian(r,e);let h=n.cartesianToCartographic(o,Ot);h.height=i-100,n.cartographicToCartesian(h,o)}var At=new dt,Vt=new a,Bt=new a,Mt=new a,Dt=new a,jt=new a,kt=new a,ft=new a,J=new a,rt=new a,zt=new E,Wt=new E,Ut=new a,Et=new ct,Gt=new W,Yt=new W;function pt(t){let e=t.vertexFormat,o=t.geometry,n=t.shadowVolume,s=o.attributes.position.values,i=P(o.attributes.st)?o.attributes.st.values:void 0,r=s.length,h=t.wall,d=t.top||h,u=t.bottom||h;if(e.st||e.normal||e.tangent||e.bitangent||n){let T=t.boundingRectangle,c=t.rotationAxis,O=t.projectTo2d,A=t.ellipsoid,B=t.stRotation,C=t.perPositionHeight,R=zt;R.x=T.x,R.y=T.y;let M=e.st?new Float32Array(2*(r/3)):void 0,m;e.normal&&(C&&d&&!h?m=o.attributes.normal.values:m=new Float32Array(r));let H=e.tangent?new Float32Array(r):void 0,x=e.bitangent?new Float32Array(r):void 0,F=n?new Float32Array(r):void 0,w=0,y=0,_=Bt,f=Mt,p=Dt,j=!0,Y=Gt,$=Yt;if(B!==0){let D=ct.fromAxisAngle(c,B,Et);Y=W.fromQuaternion(D,Y),D=ct.fromAxisAngle(c,-B,Et),$=W.fromQuaternion(D,$)}else Y=W.clone(W.IDENTITY,Y),$=W.clone(W.IDENTITY,$);let g=0,I=0;d&&u&&(g=r/2,I=r/3,r/=2);for(let D=0;D<r;D+=3){let k=a.fromArray(s,D,Ut);if(e.st&&!P(i)){let N=W.multiplyByVector(Y,k,Vt);N=A.scaleToGeodeticSurface(N,N);let S=O(N,Wt);E.subtract(S,R,S);let tt=l.clamp(S.x/T.width,0,1),et=l.clamp(S.y/T.height,0,1);u&&(M[w+I]=tt,M[w+1+I]=et),d&&(M[w]=tt,M[w+1]=et),w+=2}if(e.normal||e.tangent||e.bitangent||n){let N=y+1,S=y+2;if(h){if(D+3<r){let tt=a.fromArray(s,D+3,jt);if(j){let et=a.fromArray(s,D+r,kt);C&&St(k,tt,et,A),a.subtract(tt,k,tt),a.subtract(et,k,et),_=a.normalize(a.cross(et,tt,_),_),j=!1}a.equalsEpsilon(tt,k,l.EPSILON10)&&(j=!0)}(e.tangent||e.bitangent)&&(p=A.geodeticSurfaceNormal(k,p),e.tangent&&(f=a.normalize(a.cross(p,_,f),f)))}else _=A.geodeticSurfaceNormal(k,_),(e.tangent||e.bitangent)&&(C&&(ft=a.fromArray(m,y,ft),J=a.cross(a.UNIT_Z,ft,J),J=a.normalize(W.multiplyByVector($,J,J),J),e.bitangent&&(rt=a.normalize(a.cross(ft,J,rt),rt))),f=a.cross(a.UNIT_Z,_,f),f=a.normalize(W.multiplyByVector($,f,f),f),e.bitangent&&(p=a.normalize(a.cross(_,f,p),p)));e.normal&&(t.wall?(m[y+g]=_.x,m[N+g]=_.y,m[S+g]=_.z):u&&(m[y+g]=-_.x,m[N+g]=-_.y,m[S+g]=-_.z),(d&&!C||h)&&(m[y]=_.x,m[N]=_.y,m[S]=_.z)),n&&(h&&(_=A.geodeticSurfaceNormal(k,_)),F[y+g]=-_.x,F[N+g]=-_.y,F[S+g]=-_.z),e.tangent&&(t.wall?(H[y+g]=f.x,H[N+g]=f.y,H[S+g]=f.z):u&&(H[y+g]=-f.x,H[N+g]=-f.y,H[S+g]=-f.z),d&&(C?(H[y]=J.x,H[N]=J.y,H[S]=J.z):(H[y]=f.x,H[N]=f.y,H[S]=f.z))),e.bitangent&&(u&&(x[y+g]=p.x,x[N+g]=p.y,x[S+g]=p.z),d&&(C?(x[y]=rt.x,x[N]=rt.y,x[S]=rt.z):(x[y]=p.x,x[N]=p.y,x[S]=p.z))),y+=3}}e.st&&!P(i)&&(o.attributes.st=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:2,values:M})),e.normal&&(o.attributes.normal=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:3,values:m})),e.tangent&&(o.attributes.tangent=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:3,values:H})),e.bitangent&&(o.attributes.bitangent=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:3,values:x})),n&&(o.attributes.extrudeDirection=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:3,values:F}))}if(t.extrude&&P(t.offsetAttribute)){let T=s.length/3,c=new Uint8Array(T);if(t.offsetAttribute===ht.TOP)d&&u||h?c=c.fill(1,0,T/2):d&&(c=c.fill(1));else{let O=t.offsetAttribute===ht.NONE?0:1;c=c.fill(O)}o.attributes.applyOffset=new Z({componentDatatype:Q.UNSIGNED_BYTE,componentsPerAttribute:1,values:c})}return o}var Ht=[];function qt(t,e,o,n,s,i,r,h,d,u){let T={walls:[]},c;if(r||h){let m=L.createGeometryFromPositions(t,e,o,n,i,d,u),H=m.attributes.position.values,x=m.indices,F,w;if(r&&h){let y=H.concat(H);F=y.length/3,w=lt.createTypedArray(F,x.length*2),w.set(x);let _=x.length,f=F/2;for(c=0;c<_;c+=3){let p=w[c]+f,j=w[c+1]+f,Y=w[c+2]+f;w[c+_]=Y,w[c+1+_]=j,w[c+2+_]=p}if(m.attributes.position.values=y,i&&d.normal){let p=m.attributes.normal.values;m.attributes.normal.values=new Float32Array(y.length),m.attributes.normal.values.set(p)}if(d.st&&P(o)){let p=m.attributes.st.values;m.attributes.st.values=new Float32Array(F*2),m.attributes.st.values=p.concat(p)}m.indices=w}else if(h){for(F=H.length/3,w=lt.createTypedArray(F,x.length),c=0;c<x.length;c+=3)w[c]=x[c+2],w[c+1]=x[c+1],w[c+2]=x[c];m.indices=w}T.topAndBottom=new st({geometry:m})}let O=s.outerRing,A=X.fromPoints(O,t),B=A.projectPointsOntoPlane(O,Ht),C=nt.computeWindingOrder2D(B);C===gt.CLOCKWISE&&(O=O.slice().reverse());let R=L.computeWallGeometry(O,o,t,n,i,u);T.walls.push(new st({geometry:R}));let M=s.holes;for(c=0;c<M.length;c++){let m=M[c];B=A.projectPointsOntoPlane(m,Ht),C=nt.computeWindingOrder2D(B),C===gt.COUNTER_CLOCKWISE&&(m=m.slice().reverse()),R=L.computeWallGeometry(m,o,t,n,i,u),T.walls.push(new st({geometry:R}))}return T}function G(t){if(q.typeOf.object("options",t),q.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),P(t.perPositionHeight)&&t.perPositionHeight&&P(t.height))throw new ut("Cannot use both options.perPositionHeight and options.height");if(P(t.arcType)&&t.arcType!==at.GEODESIC&&t.arcType!==at.RHUMB)throw new ut("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let e=t.polygonHierarchy,o=v(t.vertexFormat,K.DEFAULT),n=v(t.ellipsoid,V.WGS84),s=v(t.granularity,l.RADIANS_PER_DEGREE),i=v(t.stRotation,0),r=t.textureCoordinates,h=v(t.perPositionHeight,!1),d=h&&P(t.extrudedHeight),u=v(t.height,0),T=v(t.extrudedHeight,u);if(!d){let c=Math.max(u,T);T=Math.min(u,T),u=c}this._vertexFormat=K.clone(o),this._ellipsoid=V.clone(n),this._granularity=s,this._stRotation=i,this._height=u,this._extrudedHeight=T,this._closeTop=v(t.closeTop,!0),this._closeBottom=v(t.closeBottom,!0),this._polygonHierarchy=e,this._perPositionHeight=h,this._perPositionHeightExtrude=d,this._shadowVolume=v(t.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=v(t.arcType,at.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=r,this.packedLength=L.computeHierarchyPackedLength(e,a)+V.packedLength+K.packedLength+(r?L.computeHierarchyPackedLength(r,E):1)+12}G.fromPositions=function(t){t=v(t,v.EMPTY_OBJECT),q.defined("options.positions",t.positions);let e={polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates};return new G(e)};G.pack=function(t,e,o){return q.typeOf.object("value",t),q.defined("array",e),o=v(o,0),o=L.packPolygonHierarchy(t._polygonHierarchy,e,o,a),V.pack(t._ellipsoid,e,o),o+=V.packedLength,K.pack(t._vertexFormat,e,o),o+=K.packedLength,e[o++]=t._height,e[o++]=t._extrudedHeight,e[o++]=t._granularity,e[o++]=t._stRotation,e[o++]=t._perPositionHeightExtrude?1:0,e[o++]=t._perPositionHeight?1:0,e[o++]=t._closeTop?1:0,e[o++]=t._closeBottom?1:0,e[o++]=t._shadowVolume?1:0,e[o++]=v(t._offsetAttribute,-1),e[o++]=t._arcType,P(t._textureCoordinates)?o=L.packPolygonHierarchy(t._textureCoordinates,e,o,E):e[o++]=-1,e[o++]=t.packedLength,e};var Qt=V.clone(V.UNIT_SPHERE),Zt=new K,Kt={polygonHierarchy:{}};G.unpack=function(t,e,o){q.defined("array",t),e=v(e,0);let n=L.unpackPolygonHierarchy(t,e,a);e=n.startingIndex,delete n.startingIndex;let s=V.unpack(t,e,Qt);e+=V.packedLength;let i=K.unpack(t,e,Zt);e+=K.packedLength;let r=t[e++],h=t[e++],d=t[e++],u=t[e++],T=t[e++]===1,c=t[e++]===1,O=t[e++]===1,A=t[e++]===1,B=t[e++]===1,C=t[e++],R=t[e++],M=t[e]===-1?void 0:L.unpackPolygonHierarchy(t,e,E);P(M)?(e=M.startingIndex,delete M.startingIndex):e++;let m=t[e++];return P(o)||(o=new G(Kt)),o._polygonHierarchy=n,o._ellipsoid=V.clone(s,o._ellipsoid),o._vertexFormat=K.clone(i,o._vertexFormat),o._height=r,o._extrudedHeight=h,o._granularity=d,o._stRotation=u,o._perPositionHeightExtrude=T,o._perPositionHeight=c,o._closeTop=O,o._closeBottom=A,o._shadowVolume=B,o._offsetAttribute=C===-1?void 0:C,o._arcType=R,o._textureCoordinates=M,o.packedLength=m,o};var Jt=new E,Xt=new E,$t=new z;function xt(t,e,o,n,s,i){let r=t.longitude,h=r>=0?r:r+l.TWO_PI;s.westOverIdl=Math.min(s.westOverIdl,h),s.eastOverIdl=Math.max(s.eastOverIdl,h),i.west=Math.min(i.west,r),i.east=Math.max(i.east,r);let d=t.getLatitude(o),u=d;if(i.south=Math.min(i.south,d),i.north=Math.max(i.north,d),n!==at.RHUMB){let O=E.subtract(e.position,t.position,Jt),A=E.dot(e.position,O)/E.dot(O,O);if(A>0&&A<1){let B=E.add(e.position,E.multiplyByScalar(O,-A,O),Xt),C=z.clone(e,$t);C.position=B;let R=C.getLatitude(o);i.south=Math.min(i.south,R),i.north=Math.max(i.north,R),Math.abs(d)>Math.abs(R)&&(u=R)}}let T=e.x*t.y-t.x*e.y,c=Math.sign(T);c!==0&&(c*=E.angleBetween(e.position,t.position)),u>=0&&(s.northAngle+=c),u<=0&&(s.southAngle+=c)}var Ct=new z,te=new z,U={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};G.computeRectangleFromPositions=function(t,e,o,n){if(q.defined("positions",t),P(n)||(n=new _t),t.length<3)return n;n.west=Number.POSITIVE_INFINITY,n.east=Number.NEGATIVE_INFINITY,n.south=Number.POSITIVE_INFINITY,n.north=Number.NEGATIVE_INFINITY,U.northAngle=0,U.southAngle=0,U.westOverIdl=Number.POSITIVE_INFINITY,U.eastOverIdl=Number.NEGATIVE_INFINITY;let s=t.length,i=z.fromCartesian(t[0],te);for(let r=1;r<s;r++){let h=z.fromCartesian(t[r],Ct);xt(h,i,e,o,U,n),i=z.clone(h,i)}return xt(z.fromCartesian(t[0],Ct),i,e,o,U,n),n.east-n.west>U.eastOverIdl-U.westOverIdl&&(n.west=U.westOverIdl,n.east=U.eastOverIdl,n.east>l.PI&&(n.east=n.east-l.TWO_PI),n.west>l.PI&&(n.west=n.west-l.TWO_PI)),l.equalsEpsilon(Math.abs(U.northAngle),l.TWO_PI,l.EPSILON10)&&(n.north=l.PI_OVER_TWO,n.east=l.PI,n.west=-l.PI),l.equalsEpsilon(Math.abs(U.southAngle),l.TWO_PI,l.EPSILON10)&&(n.south=-l.PI_OVER_TWO,n.east=l.PI,n.west=-l.PI),n};var ee=new z;function oe(t,e,o){return t.height>=l.PI||t.width>=l.PI?z.fromCartesian(e[0],ee).tangentPlane:X.fromPoints(e,o)}var Nt=new ot;function ne(t,e,o){return(n,s)=>{if(t.height>=l.PI||t.width>=l.PI){if(t.south<0&&t.north>0){P(s)||(s=[]);for(let r=0;r<n.length;++r){let h=o.cartesianToCartographic(n[r],Nt);s[r]=new E(h.longitude/l.PI,h.latitude/l.PI_OVER_TWO)}return s.length=n.length,s}return z.fromCartesianArray(n,s)}return X.fromPoints(e,o).projectPointsOntoPlane(n,s)}}function ie(t,e,o){if(t.height>=l.PI||t.width>=l.PI)return(s,i)=>{if(t.south<0&&t.north>0){let r=o.cartesianToCartographic(s,Nt);return P(i)||(i=new E),i.x=r.longitude/l.PI,i.y=r.latitude/l.PI_OVER_TWO,i}return z.fromCartesian(s,i)};let n=X.fromPoints(e,o);return(s,i)=>n.projectPointsOntoPlane(s,i)}function re(t,e,o,n){return(s,i)=>!n&&(t.height>=l.PI_OVER_TWO||t.width>=2*l.PI_OVER_THREE)?L.splitPolygonsOnEquator(s,e,o,i):s}function se(t,e,o,n){if(e.height>=l.PI||e.width>=l.PI)return dt.fromRectangle(e,void 0,At);let s=t,i=X.fromPoints(s,o);return L.computeBoundingRectangle(i.plane.normal,i.projectPointOntoPlane.bind(i),s,n,At)}G.createGeometry=function(t){let e=t._vertexFormat,o=t._ellipsoid,n=t._granularity,s=t._stRotation,i=t._polygonHierarchy,r=t._perPositionHeight,h=t._closeTop,d=t._closeBottom,u=t._arcType,T=t._textureCoordinates,c=P(T),O=i.positions;if(O.length<3)return;let A=t.rectangle,B=L.polygonsFromHierarchy(i,c,ne(A,O,o),!r,o,re(A,o,u,r)),C=B.hierarchy,R=B.polygons,M=function(g){return g},m=c?L.polygonsFromHierarchy(T,!0,M,!1,o).polygons:void 0;if(C.length===0)return;let H=C[0].outerRing,x=se(H,A,o,s),F=[],w=t._height,y=t._extrudedHeight,_=t._perPositionHeightExtrude||!l.equalsEpsilon(w,y,0,l.EPSILON2),f={perPositionHeight:r,vertexFormat:e,geometry:void 0,rotationAxis:oe(A,H,o).plane.normal,projectTo2d:ie(A,H,o),boundingRectangle:x,ellipsoid:o,stRotation:s,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:u},p;if(_)for(f.extrude=!0,f.top=h,f.bottom=d,f.shadowVolume=t._shadowVolume,f.offsetAttribute=t._offsetAttribute,p=0;p<R.length;p++){let g=qt(o,R[p],c?m[p]:void 0,n,C[p],r,h,d,e,u),I;h&&d?(I=g.topAndBottom,f.geometry=L.scaleToGeodeticHeightExtruded(I.geometry,w,y,o,r)):h?(I=g.topAndBottom,I.geometry.attributes.position.values=nt.scaleToGeodeticHeight(I.geometry.attributes.position.values,w,o,!r),f.geometry=I.geometry):d&&(I=g.topAndBottom,I.geometry.attributes.position.values=nt.scaleToGeodeticHeight(I.geometry.attributes.position.values,y,o,!0),f.geometry=I.geometry),(h||d)&&(f.wall=!1,I.geometry=pt(f),F.push(I));let D=g.walls;f.wall=!0;for(let k=0;k<D.length;k++){let N=D[k];f.geometry=L.scaleToGeodeticHeightExtruded(N.geometry,w,y,o,r),N.geometry=pt(f),F.push(N)}}else for(p=0;p<R.length;p++){let g=new st({geometry:L.createGeometryFromPositions(o,R[p],c?m[p]:void 0,n,r,e,u)});if(g.geometry.attributes.position.values=nt.scaleToGeodeticHeight(g.geometry.attributes.position.values,w,o,!r),f.geometry=g.geometry,g.geometry=pt(f),P(t._offsetAttribute)){let I=g.geometry.attributes.position.values.length,D=t._offsetAttribute===ht.NONE?0:1,k=new Uint8Array(I/3).fill(D);g.geometry.attributes.applyOffset=new Z({componentDatatype:Q.UNSIGNED_BYTE,componentsPerAttribute:1,values:k})}F.push(g)}let j=bt.combineInstances(F)[0];j.attributes.position.values=new Float64Array(j.attributes.position.values),j.indices=lt.createTypedArray(j.attributes.position.values.length/3,j.indices);let Y=j.attributes,$=Tt.fromVertices(Y.position.values);return e.position||delete Y.position,new mt({attributes:Y,indices:j.indices,primitiveType:j.primitiveType,boundingSphere:$,offsetAttribute:t._offsetAttribute})};G.createShadowVolume=function(t,e,o){let n=t._granularity,s=t._ellipsoid,i=e(n,s),r=o(n,s);return new G({polygonHierarchy:t._polygonHierarchy,ellipsoid:s,stRotation:t._stRotation,granularity:n,perPositionHeight:!1,extrudedHeight:i,height:r,vertexFormat:K.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})};function ae(t){let e=-t._stRotation;if(e===0)return[0,0,0,1,1,0];let o=t._ellipsoid,n=t._polygonHierarchy.positions,s=t.rectangle;return mt._textureCoordinateRotationPoints(n,e,o,s)}Object.defineProperties(G.prototype,{rectangle:{get:function(){if(!P(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=G.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return P(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=ae(this)),this._textureCoordinateRotationPoints}}});var Pt=G;function ce(t,e){let o=t.vectorTileBuilding;P(e)&&(t=Pt.unpack(t,e)),t._ellipsoid=V.clone(t._ellipsoid);let n=Pt.createGeometry(t);if(P(o)){let s=o.height,i=n.boundingSphere.center,r=a.magnitude(i),h=[],d=[];for(let u=0;u<n.attributes.position.values.length;u+=3){let T=n.attributes.position.values[u+0],c=n.attributes.position.values[u+1],O=n.attributes.position.values[u+2];d.push(s);let A=new a(T,c,O);a.magnitude(A)>r?h.push(s):h.push(0)}n.attributes.terrian=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:1,values:new Float32Array(h)}),n.attributes.height=new Z({componentDatatype:Q.FLOAT,componentsPerAttribute:1,values:new Float32Array(d)})}return n}var eo=ce;export{eo as default};
